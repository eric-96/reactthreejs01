/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: BlueMesh (https://sketchfab.com/VapTor)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/s9-mini-drone-cf3ed83c1b87486d90435f54c074e16e
Title: S9 Mini Drone
*/

import * as THREE from "three";
import { useRef, useEffect, useState } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { a } from "@react-spring/three";
import drone3d from "../assets/assets/3d/drone.glb";

import { Environment } from '@react-three/drei';

const Drone = ({ isRotating, setIsRotating, setCurrentStage, ...props}) => {
  const group = useRef();
  const { gl, viewport } = useThree();
  const { nodes, materials, animations } = useGLTF(drone3d);
  const { actions } = useAnimations(animations, group);
  const actionRef = useRef();

  const lastX = useRef(0);
  const lastY = useRef(0);
  const rotationSpeed = useRef(0);
  const dampingFactor = 0.95;


  useEffect(() => {
    if (actions && actions["Take 01"]) {
      actionRef.current = actions["Take 01"];
      actionRef.current.setLoop(THREE.LoopRepeat, Infinity); // Infinity will make it loop continuously
      actionRef.current.clampWhenFinished = false;
      actionRef.current.play();
    }
  }, [actions]);

  const handlePointerDown = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(true);
  
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  
    lastX.current = clientX;
    lastY.current = clientY;
  };

  const handlePointerUp = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(false);
  };

  const handlePointerMove = (e) => {
    e.stopPropagation();
    e.preventDefault();
  
    if(isRotating) { 
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const deltaX = (clientX - lastX.current) / viewport.width;
      const deltaY = (clientY - lastY.current) / viewport.height;
  
      group.current.rotation.y += deltaX * Math.PI * 0.01;
      group.current.rotation.x += deltaY * Math.PI * 0.01;
  
      lastX.current = clientX;
      lastY.current = clientY;
  
      rotationSpeed.current = Math.sqrt(deltaX * deltaX + deltaY * deltaY) * 0.01 * Math.PI;
    }
  };

  const handleKeyDown = (e) => {
    if(e.key === "ArrowLeft") {
      if(!isRotating) setIsRotating(true);
      group.current.rotation.y += 0.1 * Math.PI;
    } else if(e.key === "ArrowRight") {
      if(!isRotating) setIsRotating(true);
      group.current.rotation.y -= 0.1 * Math.PI;
    }
  }

    const handleKeyUp = (e) => {
      if(e.key === "ArrowLeft" || e.key === "ArrowRight") {
        setIsRotating(false);
      }
    };

    useFrame(() => {
      if(!isRotating) {
        rotationSpeed.current *= dampingFactor;

        if(Math.abs(rotationSpeed.current) < 0.001) {
          rotationSpeed.current = 0;
        }

        group.current.rotation.y += rotationSpeed.current;
      } else { 
        const rotation = group.current.rotation.y;
       /**
       * Normalize the rotation value to ensure it stays within the range [0, 2 * Math.PI].
       * The goal is to ensure that the rotation value remains within a specific range to
       * prevent potential issues with very large or negative rotation values.
       *  Here's a step-by-step explanation of what this code does:
       *  1. rotation % (2 * Math.PI) calculates the remainder of the rotation value when divided
       *     by 2 * Math.PI. This essentially wraps the rotation value around once it reaches a
       *     full circle (360 degrees) so that it stays within the range of 0 to 2 * Math.PI.
       *  2. (rotation % (2 * Math.PI)) + 2 * Math.PI adds 2 * Math.PI to the result from step 1.
       *     This is done to ensure that the value remains positive and within the range of
       *     0 to 2 * Math.PI even if it was negative after the modulo operation in step 1.
       *  3. Finally, ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI) applies another
       *     modulo operation to the value obtained in step 2. This step guarantees that the value
       *     always stays within the range of 0 to 2 * Math.PI, which is equivalent to a full
       *     circle in radians.
       */
       const normalizedRotation =
       ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

     // Set the current stage based on the drone's orientation
     switch (true) {
       case normalizedRotation >= 5.45 && normalizedRotation <= 5.85:
         setCurrentStage(4);
         break;
       case normalizedRotation >= 0.85 && normalizedRotation <= 1.3:
         setCurrentStage(3);
         break;
       case normalizedRotation >= 2.4 && normalizedRotation <= 2.6:
         setCurrentStage(2);
         break;
       case normalizedRotation >= 4.25 && normalizedRotation <= 4.75:
         setCurrentStage(1);
         break;
       default:
         setCurrentStage(null);
     }
   }
 });

  useEffect(() => {
    const canvas = gl.domElement;
    canvas.addEventListener("pointerdown", handlePointerDown);
    canvas.addEventListener("pointerup", handlePointerUp);
    canvas.addEventListener("pointermove", handlePointerMove);
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);

    return () => {
      canvas.removeEventListener("pointerdown", handlePointerDown);
      canvas.removeEventListener("pointerup", handlePointerUp);
      canvas.removeEventListener("pointermove", handlePointerMove);
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
    };
  }, [gl, handlePointerDown, handlePointerUp, handlePointerMove]);



  return (
    <>
    <>
    <a.group ref={group} {...props} dispose={null}>
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]}>
          <group name="Root">
            <group name="Circle" position={[1.378, 1.984, 0.607]} scale={0.421}>
              <mesh
                name="Circle_0"
                castShadow
                receiveShadow
                geometry={nodes.Circle_0.geometry}
                material={materials["Material.001"]}
              />
              <mesh
                name="Circle_1"
                castShadow
                receiveShadow
                geometry={nodes.Circle_1.geometry}
                material={materials["Material.003"]}
              />
            </group>
            <group name="Circle001" position={[3.077, 2.731, -0.052]}>
              <mesh
                name="Circle001_0"
                castShadow
                receiveShadow
                geometry={nodes.Circle001_0.geometry}
                material={materials["Material.001"]}
              />
              <mesh
                name="Circle001_1"
                castShadow
                receiveShadow
                geometry={nodes.Circle001_1.geometry}
                material={materials["Material.003"]}
              />
            </group>
            <group
              name="Cube"
              position={[0.016, 0.269, 0]}
              scale={[1.181, 1, 1]}
            >
              <mesh
                name="Cube_0"
                castShadow
                receiveShadow
                geometry={nodes.Cube_0.geometry}
                material={materials["Material.001"]}
              />
              <mesh
                name="Cube_1"
                castShadow
                receiveShadow
                geometry={nodes.Cube_1.geometry}
                material={materials["Material.002"]}
              />
            </group>
            <group
              name="Sphere"
              position={[0.048, 2.873, -0.188]}
              scale={[0.096, 0.096, 0.121]}
            >
              <mesh
                name="Sphere_0"
                castShadow
                receiveShadow
                geometry={nodes.Sphere_0.geometry}
                material={materials["Material.005"]}
              />
            </group>
            <group
              name="Sphere001"
              position={[-0.002, -2.487, -0.124]}
              scale={[0.174, 0.13, 0.163]}
            >
              <mesh
                name="Sphere001_0"
                castShadow
                receiveShadow
                geometry={nodes.Sphere001_0.geometry}
                material={materials["Material.004"]}
              />
            </group>
            <group
              name="Cube001"
              position={[1.136, 0.834, 0.278]}
              scale={[0.101, 0.05, 0.05]}
            >
              <mesh
                name="Cube001_0"
                castShadow
                receiveShadow
                geometry={nodes.Cube001_0.geometry}
                material={materials["Cylinder.001_0"]}
              />
            </group>
            <group
              name="Circle002"
              position={[3.059, 2.733, 1.004]}
              rotation={[0, 0, 0.052]}
              scale={0.147}
            >
              <mesh
                name="Circle002_0"
                castShadow
                receiveShadow
                geometry={nodes.Circle002_0.geometry}
                material={materials.pale}
              />
            </group>
            <group
              name="Circle003"
              position={[-3.035, 2.754, 1.004]}
              rotation={[0, 0, -1.435]}
              scale={0.147}
            >
              <mesh
                name="Circle003_0"
                castShadow
                receiveShadow
                geometry={nodes.Circle003_0.geometry}
                material={materials.pale}
              />
            </group>
            <group
              name="Circle004"
              position={[-3.035, -2.19, 1.004]}
              rotation={[0, 0, -0.391]}
              scale={0.147}
            >
              <mesh
                name="Circle004_0"
                castShadow
                receiveShadow
                geometry={nodes.Circle004_0.geometry}
                material={materials.pale}
              />
            </group>
            <group
              name="Circle005"
              position={[3.047, -2.187, 1.004]}
              rotation={[0, 0, -1.36]}
              scale={0.147}
            >
              <mesh
                name="Circle005_0"
                castShadow
                receiveShadow
                geometry={nodes.Circle005_0.geometry}
                material={materials.pale}
              />
            </group>
            <group
              name="Cylinder"
              position={[0.057, 3.094, 0.252]}
              rotation={[Math.PI / 2, 0, 0]}
              scale={0.122}
            >
              <mesh
                name="Cylinder_0"
                castShadow
                receiveShadow
                geometry={nodes.Cylinder_0.geometry}
                material={materials["Cylinder.001_0"]}
              />
            </group>
            <group
              name="Cylinder001"
              position={[-0.06, 3.094, 0.252]}
              rotation={[Math.PI / 2, 0, 0]}
              scale={0.122}
            >
              <mesh
                name="Cylinder001_0"
                castShadow
                receiveShadow
                geometry={nodes.Cylinder001_0.geometry}
                material={materials["Cylinder.001_0"]}
              />
            </group>
            <group
              name="Circle006"
              position={[0.003, 0.457, -4.295]}
              scale={12.303}
            >
              <mesh
                name="Circle006_0"
                castShadow
                receiveShadow
                geometry={nodes.Circle006_0.geometry}
                material={materials["Material.006"]}
              />
            </group>
          </group>
        </group>
      </group>
    </a.group>
    </>
    <Environment preset="sunset" />
    </>
  );
}

export default Drone;